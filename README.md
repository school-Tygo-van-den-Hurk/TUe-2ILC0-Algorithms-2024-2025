> I'll use this repository to store the algorithms I develop for the assignments, and any other things I might have to write.

# Algorithms
In this course, you'll learn various techniques for solving optimization problems such as the Traveling Salesman Problem. You'll also learn about the limits of what can be computed efficiently, by studying the theory of NP-completeness.

The efficiency of algorithms is of crucial importance in many applications. In the course Data Structures you have learned how to mathematically analyze efficiency, how to use design techniques like divide-and-conquer, and you have seen efficient algorithms and data structures for basic problems such as sorting and searching. In the course Algorithms we will take this one step further, by studying more advanced design techniques and algorithms, and by studying limitations of what can be achieved by efficient algorithms. Many of the topics that are covered concern optimization problems, where one wants to find not just some solution to a problem but an optimal solution. The course consists of three parts.

Algorithmic techniques for optimization.  In this part of the course we study three general techniques for solving optimization problems: backtracking, dynamic programming, and greedy algorithms. Backtracking can be applied to more or less all problems but it generally yields very slow algorithms, a greedy approach can be applied to few problems but it generally gives very fast algorithms, and dynamic programming lies in between.

Graph algorithms.  The second part of the course deals with algorithms for optimization problems on graphs: computing shortest paths, computing maximum flows, and finding so-called matchings.

Computational complexity.  In the third part of the course we study the limitations of traditional algorithm design and analysis. We consider problems for which it seems impossible to design efficient algorithms and introduce the concept of NP-hardness which formalizes this.
